---
- hosts: clients
  gather_facts: no
  vars_files:
   - [ "~/vars/f5aws/env/{{ env_name }}/{{ inventory_hostname }}.yml" ]
  tasks:
    - name: Add CFT output variables to host from persisted results from previous playbooks
      set_fact:
        ansible_ssh_host={{ hostvars[inventory_hostname].stack_outputs.ClientInstancePublicIp }}
        ClientInstancePublicIp={{ hostvars[inventory_hostname].stack_outputs.ClientInstancePublicIp }}
        ClientInstancePrivateIp={{ hostvars[inventory_hostname].stack_outputs.ClientInstancePrivateIp }}

# Need to wait for port 22 to open up
- hosts: clients
  gather_facts: no
  tasks:
    - local_action: wait_for host={{ ansible_ssh_host }} search_regex=OpenSSH delay=10 port=22
  sudo: false

# Now launch containers inside them
# Amazon amis we're using already have docker installed so no need for install_docker role
- hosts: clients
  gather_facts: no
  vars:
    ansible_sudo: True
  roles:
    # - jumpbox
    - client

# Modify Jmeter Scripts to hit vips or wideips
# Means replacing hostnames with BIGIP-VIPs jmeter files themselves (No DNS requirement)

#ex.
#    - replace: dest=~/simple-load-generation.jmx regexp='demo.example.com' replace='{{VIP}}'
# OR
# modify /etc/resolv.conf to resolve example.com at GTM Listener
# so first need to load GTM listeners again (Vip1)


# Add CFT output variables to host from persisted results from previous playbooks
- hosts: gtms
  gather_facts: no
  vars_files:
   - [ "~/vars/f5aws/env/{{ env_name }}/{{ inventory_hostname }}.yml" ]
  tasks:
    - name: Add CFT output variables to host from persisted results from previous playbooks
      set_fact:
        ansible_ssh_host={{ hostvars[inventory_hostname].stack_outputs.ManagementInterfacePublicIp }}
        ManagementInterfacePublicIp={{ hostvars[inventory_hostname].stack_outputs.ManagementInterfacePublicIp }}
        ManagementInterfacePrivateIp={{ hostvars[inventory_hostname].stack_outputs.ManagementInterfacePrivateIp }}
        ExternalInterfacePublicIp={{ hostvars[inventory_hostname].stack_outputs.ExternalInterfacePublicIp }}
        ExternalInterfacePrivateIp={{ hostvars[inventory_hostname].stack_outputs.ExternalInterfacePrivateIp }}
        VipAddress={{ hostvars[inventory_hostname].stack_outputs.Vip1 }}
        region="{{region}}"

### Example Default /etc/resolv.conf in AWS ####

# ubuntu@ip-172-16-13-4:~$ cat /etc/resolv.conf
# # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# nameserver 172.16.0.2
# search ec2.internal
#

# Modify Nameservers 
- hosts: clients
  gather_facts: no
  vars:
    ansible_sudo: True
  tasks:
    - name: Grab number of existing name servers
      shell: "egrep -c nameserver /etc/resolv.conf"
      ignore_errors: true
      register: nameserver_count

    # Need to place GTMs first. 
    - name: Add example.com nameservers to /etc/resolv.conf if just default one nameserver
      shell: "echo 'nameserver {{hostvars[item]['VipAddress']}}' >> /etc/resolvconf/resolv.conf.d/head"
      #shell: "echo $(echo 'nameserver {{hostvars[item]['VipAddress']}}\n' | cat - /etc/resolv.conf ) >> /etc/resolv.conf"
      with_items: groups['gtms'] 
      when: nameserver_count.stdout|int < 2

    #Restart resolvconf to pickup changes
    - name: restart resolvconf
      shell: resolvconf -u 

# Upload Jmeter scripts
- hosts: clients
  gather_facts: no
  tasks:

    - name: Copy over simple load generation jmeter script
      copy: src=../roles/client/files/simple-load-generation.jmx dest=~/

    - name: Copy over attack jmeter script
      copy: src=../roles/client/files/attack-site.jmx dest=~/
